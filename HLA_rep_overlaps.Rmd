```{r, warning=FALSE, echo=FALSE}
# source('~/antigenic_space/bin/install_packages.R')
# devtools::install(file.path('~/libs', 'maartenutils'))
devtools::load_all(file.path('~/antigenic_space', 'libs', 'fasanalysis'))
devtools::load_all(file.path('~/libs', 'quickMHC'))
library(glue)
pacman::p_load('rmarkdown')
pacman::p_load('data.table')
pacman::p_load('ggrepel')
pacman::p_load('purrr')
# define_pkg_var()

editing_root <- path.expand(file.path(ma_dir, 'immune_editing'))
setwd(editing_root)

## read-in MHC typing data
if (F) {
  fn <- file.path(editing_root, 'TCGA_HLA_Optitype.csv')
# less(fn)
  optitype_tcga <- w_fread(fn)
  setnames(optitype_tcga, 'cancertype', 'project')
  setnames(optitype_tcga, 'subject', 'donor_id')
## Restrict to donors of interest
  optitype_tcga <- optitype_tcga[donor_id %in% core_donors]
  w_saveRDS('optitype_tcga')
} else {
  w_readRDS('optitype_tcga')
}

all_a_types <- optitype_tcga[, unique(c(`hla_a1`, `hla_a2`))] %>% sort
all_b_types <- optitype_tcga[, unique(c(`hla_b1`, `hla_b2`))] %>% sort
# w_saveRDS('all_a_types')
# w_saveRDS('all_b_types')


#' Sample from HLA frequency table
#'
#'
sample_from_hla <- function(types = all_a_types, size = 2) {
  sample(x = names(types), size = size, prob = types, replace = T)
}

if (F) {
  ## Read in all-filter passing peptides for HLA-typed donors
  candidate_peps <- rbindlist(lapply(optitype_tcga[, donor_id],
                                     function(donor_id) {
    # ann_predictions <- master_read_predictions(donor_id)
    # peps <- ann_predictions$peps
    peps <- compile_peps(donor_id, opts = default_opts,
                         use_fread = F, type = 'focal')
    peps <- filter_peptides(peps, opts = default_opts)
    return(peps[, .(donor_id, tumor_peptide)])
  }), fill = T)
  candidate_peps <- candidate_peps[!is.na(tumor_peptide)]

  saveRDS(candidate_peps,
          file = file.path(editing_root, 'rds', 'candidate_peps.rds'))
} else {
  candidate_peps <-
    readRDS(file = file.path(editing_root, 'rds', 'candidate_peps.rds'))
  # candidate_peps <- readRDS(file = file.path(ma_dir, 'rds', 'candidate_peps.rds'))
}

## Expected file size of storing rank scores with 32 bit floats
# candidate_peps[, uniqueN(tumor_peptide)] * 230 * 32 * 1.25e-5
```

```{r}
## As determined using MHCcluster, May 9th 2017
a02_likes <-
  c('HLA-A02:01', 'HLA-A02:06', 'HLA-A02:05', 'HLA-A02:01',
    'HLA-A02:07', 'HLA-A68:02')

# A check, relatively few A:02:01-likes
# optitype_tcga <- define_hla_similars(.2)
# optitype_tcga[, table(hla_a0201_status) / length(hla_a0201_status)]
```


# Prevalence of HLAs

```{r, eval=F, warning=FALSE, echo=FALSE}
optitype_tcga[, sort(table(c(hla_a1, hla_a2)), decreasing = T)]
optitype_tcga[, sort(table(c(hla_b1, hla_b2)), decreasing = T)]
optitype_tcga[, sort(table(c(hla_a1, hla_a2, hla_b1, hla_b2)),
  decreasing = T)][1:5]
prevalent_missing_hlas <- c('A0101', 'A0301', 'A0801')
```


```{r}
no_hla_opts <- default_opts
no_hla_opts$affinity_threshold <- 255
no_hla_opts$nmd_filtering <- F
no_hla_opts$processing_threshold <- 0
no_hla_opts$sts_filtering <- F

if (F) {
  ## Read in all all-filter passing peptides for HLA-typed donors
  ## a2_peps is a misnomer (used for code-consistency/laziness?), it should be
  ## all_peps or something along those lines, in which A2-binding is annotated
  a2_peps <- rbindlist(lapply(optitype_tcga[, donor_id],
                       function(l_donor_id) {
    # l_donor_id = optitype_tcga[, donor_id[1]]
    message(l_donor_id)
    # ann_predictions <- master_read_predictions(donor_id)
    # peps <- ann_predictions$peps
    ## Query all candidate, unfiltered, peps
    peps <- compile_peps(l_donor_id, opts = no_hla_opts,
                         use_fread = F, type = 'focal')
    f_peps <- filter_peptides(peps, opts = no_hla_opts)
    peps[, A2_peptide := NULL]
    peps[rna_expression > 0, 'A2_peptide' :=
         tumor_peptide %in% f_peps$tumor_peptide]
    browser(expr = peps[, sum(A2_peptide, na.rm = T)] != nrow(f_peps))
    if (null_dat(peps)) return(NULL)
    return(peps[, .('donor_id' = l_donor_id, tumor_peptide, A2_peptide)])
  }), fill = T)
  a2_peps <- a2_peps[!is.na(tumor_peptide)]
  a2_peps <- a2_peps[!is.na(A2_peptide)]
  saveRDS(a2_peps, file = file.path(editing_root, 'rds', 'a2_peps.rds'))
} else {
  a2_peps <- readRDS(file = file.path(editing_root, 'rds', 'a2_peps.rds'))
  # candidate_peps <- readRDS(file = file.path(ma_dir, 'rds', 'candidate_peps.rds'))
}

## Expected file size of storing rank scores with 32 bit floats
# candidate_peps[, uniqueN(tumor_peptide)] * 230 * 32 * 1.25e-5
```

## A2-peptides presented by other alleles

```{r}
## 1.9 for 255 nM
# percentile_rank <- read_hla_predictions('HLA-A02:01')[.N, rank]
percentile_rank <- 1.9

if (F) {
  passing_by_hla <- rbindlist(plyr::llply(c(all_a_types, all_b_types),
                              function(hla_allele) {
    message(hla_allele)
    fh <- read_hla_predictions(hla_allele)
    return(fh[rank <= percentile_rank, cbind(hla_allele, .SD)])
  }, .parallel = T), fill = T)
  setkey(passing_by_hla, tumor_peptide)
  w_saveRDS('passing_by_hla')
} else {
  w_readRDS('passing_by_hla')
}
```

## 2018-08-23 14:29 Presentation of all candidate peps by all donor alleles

```{r}
library(magrittr)
## 1.9 for 255 nM
# percentile_rank <- read_hla_predictions('HLA-A02:01')[.N, rank]
percentile_rank <- 1.9

## Donor specific version, only compare against HLA alleles found in the same
## patient
all_peps_all_hlas <- rbindlist(plyr::llply(optitype_tcga[, unique(donor_id)],
                               function(l_donor_id) {
  fn <- file.path(ma_dir, 'immune_editing', 'non_A2_pep_presentation',
                  sprintf('all_peps_all_hlas_%s.rds', l_donor_id))
  if (file.exists(fn)) return(readRDS(fn))

  ## Compile all, unfiltered, peps
  peps <- compile_peps(l_donor_id, opts = no_hla_opts,
                       use_fread = F, type = 'focal')
  if (null_dat(peps)) return(NULL)
  hla_types <- optitype_tcga[donor_id == l_donor_id,
                             .(hla_a1, hla_a2, hla_b1, hla_b2)] %>% unlist
  test_peps <- peps[rna_expression > 0, tumor_peptide]
  if (is.null(test_peps) || length(test_peps) == 0) return(NULL)

  passing_by_hla <- rbindlist(plyr::llply(hla_types, function(hla_allele) {
    message(hla_allele)
    fh <- read_multiple_hla_predictions(hla_allele, peps = test_peps)
  }, .parallel = F), fill = T)
  setkey(passing_by_hla, peptide)
  saveRDS(passing_by_hla, fn)
  return(passing_by_hla)
}, .parallel = T), fill = T)

saveRDS(all_peps_all_hlas,
  file.path(ma_dir, 'immune_editing', 'all_peps_all_hlas.rds'))
```


# Overlap analysis by HLA type

2018-12-23 10:05

Major revision, compute similarity over all peptides and all
HLAs

```{r, warning=FALSE, echo=FALSE}
unloadNamespace('fasutils')
devtools::load_all(file.path('~/libs', 'maartenutils'))
devtools::load_all(file.path('~/antigenic_space', 'libs', 'fasanalysis'))
devtools::load_all(file.path('~/libs', 'quickMHC'))

invisible(w_readRDS('optitype_tcga'))
all_hlas <-
  optitype_tcga[, unique(c(`hla_a1`, `hla_a2`, `hla_b1`, 
                           `hla_b2`, `hla_c1`, `hla_c2`))] %>%
  sort %>% quickMHC::shortenHLA()

l_hlas = hlas
l_hlas = all_hlas
l_peps = sample(all_peps, 1e6)
l_peps = sample(all_peps)
ncores = 1
ncores = 24
save_bool = T
redo <- T

N_peps <- length(l_peps)
batch_size <- min(max(ceiling(N_peps / ncores), 1e4), 1e5)
batches <- split(l_peps, ceiling(seq_along(l_peps) / batch_size))
N_batches <- length(batches)
weights <- sapply(batches, length) %>% { ./sum(.) }


format_BA_l <- function(hla, peps) {
  l_hla <- hla
  query_table <- data.frame('hla_allele' = l_hla, 'peptide' = peps)
  l_BA_table <- quickMHC(query_table)
  # idx <- 1
  # while(l_BA_table[, any(is.na(percentile_rank))] && idx <= 5) {
  #   l_BA_table <- quickMHC(query_table)
  #   idx <- idx + 1
  # }
  setkey(l_BA_table, peptide)
  l_BA_table <- l_BA_table[peps, .(peptide, percentile_rank)]
  setnames(l_BA_table, 'percentile_rank', l_hla)
  return(l_BA_table)
}


gen_percentile_rank_by_hla_matrix <- function(hlas, peps) {
  for (i in seq_along(hlas)) {
    hla <- hlas[i]
    l_BA_table <- format_BA_l(hla, peps)
    if (i == 1) {
      percentile_rank_by_hla <- l_BA_table
    } else {
      ## Iteratively add a column for each allele
      percentile_rank_by_hla <- tryCatch(merge(
          percentile_rank_by_hla, l_BA_table, by = 'peptide', all = F),
        error = function(e) { print(e); browser() })
      tryCatch(rm(l_BA_table, envir = globalenv()),
        error = function(e) { print(e) })
    }
  }
  return(percentile_rank_by_hla)
}


corrob_hla_2D <- plyr::llply(auto_name(perc_ranks),
  function(percentile_rank) {
  if (ncores > 1) {
    doParallel::registerDoParallel(cores = ncores)
  }
  l_fn <- file.path(rds_dir, sprintf('OM_%.1f.rds', percentile_rank))
  if (!file.exists(l_fn) || redo) {
    OMs <- plyr::llply(seq_along(batches), function(i) {
      mymessage(sprintf('%.1f, batch %d/%d', percentile_rank, i, N_batches))
      batch_peps <- batches[[i]]
      passing_by_hla <- 
        gen_percentile_rank_by_hla_matrix(l_hlas, batch_peps) %>%
        { .[, l_hlas, with = F] <= percentile_rank }
      OM <- maartenutils::overlap_analysis(passing_by_hla,
                                           method = 'corroboration')
      mymessage(sprintf('%.1f, batch %d/%d - finished OM',
          percentile_rank, i, N_batches))
      ## Weigh OM by the relative amount of peptides in this batch
      ## Perform multiplication in log space to avert machine precision
      ## underflow errors
      # OM_w <- exp(log(OM) + log(weights[i]))
      OM_w <- OM * weights[i]
      return(OM_w)
    }, .parallel = ncores > 1)
    saveRDS(OMs, l_fn)
  } else {
    OMs <- readRDS(l_fn)
  }
  res <- purrr::reduce(OMs, `+`)
  print(head(res))
  return(res)
}, .parallel = F)

if (save_bool)
  w_saveRDS('corrob_hla_2D')
```

2019-01-01 09:19 Inspect results, they finally look OK

```{r, warning=FALSE, echo=FALSE}
# saveRDS(corrob_hla_2D, file.path(rds_dir, 'corrob_hla_2D.bak.rds'))
w_readRDS('corrob_hla_2D')
corrob_hla_2D[[1]][1:5, 1:40]
dim(corrob_hla_2D[[1]])
any(is.na(corrob_hla_2D[[4]]))
M <- corrob_hla_2D[['1.9']]
all(eps(diag(M), 1))
```

Correspondence with earlier, much smaller and A2-centric analysis

```{r, warning=FALSE, echo=FALSE}
# devtools::install(file.path('~/libs', 'maartenutils'))
devtools::load_all(file.path('~/antigenic_space', 'libs', 'fasanalysis'))
devtools::load_all(file.path('~/libs', 'quickMHC'))
## 2018-12-23 11:57
## Earlier version focused on A0201 (see commits prior to 2018-12-23 11:16 for
## the generating code), check consistency of results
w_readRDS('corrob_hla')
w_readRDS('corrob_hla_2D')

sanity_check <- merge(
  corrob_hla[, .('hla' = shorten_HLA(hla_allele), 'old_corrob' = corrob)],
  named_vec_to_dt(corrob_hla_2D[['1.9']]['A0201', ], 'hla', 'new_corrob'),
  by = 'hla', all = T)

sanity_check[, hist(old_corrob - new_corrob)]
sanity_check[eps(old_corrob, new_corrob, 1e-1)]
## 207 /
```

Plotting of results, corroboration happens mostly between alleles with the same
supertype, but interesting 'off-diagonal' patterns occur as well.
Code moved to `maarten-analyses/fas_shared_analyses/fig_prepare_revisions.Rmd`

## 2018-12-23 17:01 Investigate difference in similarity between percentile rank values

These seem pretty minimal, maximal coefficient of variation is 1.5.
This means it's safe to use a single percentile rank score for HLA similarity

```{r, warning=FALSE, echo=FALSE}
## Merge results into a 3 dimensional matrix
M <- sapply(corrob_hla_2D, identity, simplify = 'array')
str(M)
## Compute CoV over the first two dimensions, i.e. the CoV over the percentile
## ranks (third dimension)
coef_var <- function(vec) sd(vec, na.rm = T) / mean(vec, na.rm = T)
coef_var <- function(vec) sd(vec, na.rm = T)
covs <- apply(M, 1:2, coef_var)
## Show results, the clustering is not required
# pheatmap::pheatmap(covs)

fn <- file.path(img_loc, 'HLA_corrob_stability_heatmap.pdf')
pheatmap::pheatmap(covs,
  cluster_rows = F,
  cluster_cols = F,
  width = 17.4/2.54, height = 17.4/2.54,
  annotation_row = ann,
  annotation_col = ann,
  annotation_colors = ann_colors,
  fontsize = 3,
  filename = fn)
sys_file_open(fn)
```

```{r, warning=FALSE, echo=FALSE}
indxs <- which(eps(covs, max(covs)), arr.ind = T)
colnames(covs)[indxs[1, c(1, 2)]]
matrix(colnames(covs)[indxs], ncol = 2)
covs[1, 5]
```

2018-12-23 11:53 Old visualisation of HLA similarity

```{r, warning=FALSE, echo=FALSE}
library(ggrepel)
my_rank_percentile <- function(vec, ties.method = 'max') {
  ranks <- frank(vec, ties.method = ties.method) - 1
  ranks / max(ranks)
}
w_readRDS('corrob_hla')
corrob_hla <- corrob_hla[order(corrob)]
corrob_hla[, 'rank_perc' := my_rank_percentile(corrob)]
corrob_hla[grepl('HLA-A02.*', hla_allele)]
corrob_hla[, summary(corrob)]
# round(corrob_hla[, summary(corrob)][1] * nrow(candidate_peps))
corrob_hla[corrob == 1]
corrob_hla[, 'print_label' :=
 gsub('HLA-([A-C])([0-9]{2}):([0-9]{2})', 'HLA-\\1*\\2-\\3', hla_allele)]

hla_corrob_thresh <- .2

p <- ggplot(corrob_hla, aes(x = rank_perc, y = corrob)) +
  geom_hline(yintercept = .2, col = 'red', alpha = .4) +
  geom_point(size = .5) +
  geom_label_repel(data = corrob_hla[corrob >= hla_corrob_thresh],
            aes(label = print_label),
            color = 'black',
            hjust = -.2,
            label.padding = unit(0.1, "lines"),
            segment.size = .2,
            segment.colour = 'black',
            segment.alpha = 0.5,
            min.segment.length = 0,
            size = 2,
            show.legend = F, alpha = .8) +
  scale_x_continuous(name = 'Rank quantile',
                     expand = c(0, 0)) +
  scale_y_continuous(name = 'Fraction of HLA-A*02:01 peptides bound',
                     expand = c(0, 0)) +
  theme_fas()

print(p)

# w_ggsave('hla-a0201_frac_peptides_presented_by_other_alleles.pdf',
#        width = 11, height=16, units = 'cm')
maartenutils::w_ggsave(plot = p,
  fn = 'hla-a0201_frac_peptides_presented_by_other_alleles',
  img_folder = grob_loc,
  filetypes = c('pdf', 'grob'),
  w=70, h=120, units = 'mm')
```

# Per donor overlap in A2-peptide presentation

2019-01-01 16:36 Query allele peptides are filtered for binding affinity and NMD
and expression but not STS and proteasomal processing.  Corroboration allele
peptides, a subset of the peptides presented by the anchor allele, the are
subsequently filtered for binding affinity only.  Ideally, I would have filtered
the anchor HLA peptides only for binding affinity as well.

```{r}
devtools::load_all(file.path('~/antigenic_space', 'libs', 'fasanalysis'))
devtools::load_all(file.path('~/libs', 'quickMHC'))
# close_all_connections()
invisible(w_readRDS('hla_class_dat'))
setkey(hla_class_dat, donor_id)
library(magrittr)
options(warn = 1)

find_donor_overlap <- function(
  donor_id = CCF_eligible_donors[2],
  anchor_hla_allele = 'A0201',
  percentile_rank = 1.9) {

  if (donor_id %nin% hla_class_dat[, donor_id]) {
    return(NULL)
  }
  message(donor_id)
  donor_hlas <- hla_class_dat[donor_id, .(hla_a1, hla_a2, hla_b1, hla_b2)] %>%
    unlist %>% setdiff(anchor_hla_allele)

  ## Peptides presented by the anchor allele for this donor
  donor_peps <- compile_peps(donor_id = donor_id,
    hla_allele = anchor_hla_allele)

  loc_opts <- default_opts
  loc_opts[['hla_allele']] <- anchor_hla_allele
  loc_opts[['percentile_rank']] <- percentile_rank
  loc_opts[['sts_filtering']] <- F
  loc_opts[['nmd_filtering']] <- F

  donor_peps %<>% filter_peptides(donor_id = donor_id, opts = loc_opts)
  if (null_dat(donor_peps)) {
    warningf('No peptides for %s-%s', donor_id, anchor_hla_allele)
    return(NULL)
  }
  donor_peps %<>% select(tumor_peptide) %>% unlist %>% setNames(NULL)

  ## Look up corroborated peptides, i.e. anchor-peptides also presented by other
  ## alleles this donor carries
  corr_peps <- sapply(donor_hlas, function(l_hla) {
    l_BA_table <- data.frame(peptide = donor_peps, hla = l_hla) %>%
      quickMHC
    setkey(l_BA_table, peptide)
    l_BA_table[donor_peps, percentile_rank] <= percentile_rank
    ## To incorporate STS, we'd need to first run STS for all alleles, not just
    ## the anchor alleles...
    # l_STS_table <- load_STS_table(
    #   allele = l_hla, percentile_rank = percentile_rank)
    # setkey(l_STS_table, peptide)
      # l_STS_table[donor_peps, different_from_self]
  })

  N_anchor_peps <- ifelse(is.vector(corr_peps),
    length(corr_peps) / length(donor_hlas), nrow(corr_peps))
  N_promiscuous <- ifelse(is.vector(corr_peps),
    as.integer(any(corr_peps, na.rm = T)),
    sum(apply(corr_peps, 1, any), na.rm = T))

  res <- list(
    'hla_allele' = anchor_hla_allele,
    'percentile_rank' = percentile_rank,
    'donor_id' = donor_id,
    'N_anchor_peps' = N_anchor_peps,
    'N_promiscuous' = N_promiscuous)
  print(res)
  return(res)
}
invisible(w_readRDS('IE_donors'))
find_donor_overlap(IE_donors[100])
```

```{r, warning=FALSE, echo=FALSE}
parallel = T
if (!parallel) {
  ## Pre load BA tables so they'll be available from the global env.
  # for (hla in ls(BA_tables)) {
  #   mymessage(instance = 'preload_HLA', hla)
    # BA_table <- get(hla, BA_tables)
  # }
} else {
  doParallel::registerDoParallel(cores = 16)
  # library(parallel)
  # cl <- makeCluster(12, type='FORK')
  # doParallel::registerDoParallel(cl)
}

invisible(w_readRDS('IE_donors'))
# mygrid <- expand.grid('hla_allele' = hlas, 'donor_id' = sample(IE_donors, 3))
mygrid <- expand.grid('hla_allele' = hlas, 'donor_id' = IE_donors)

corrob_dat_multiple_alleles <-
  ## Compute corroboration rate := # corroborated by 'other' allele / # anchor allele peps
  plyr::llply(1:nrow(mygrid), function(idx) {
    donor_id <- as.character(mygrid[idx, 'donor_id'])
    hla_allele <- as.character(mygrid[idx, 'hla_allele'])
    find_donor_overlap(donor_id = donor_id,
      anchor_hla_allele = hla_allele,
      percentile_rank = 1.9)
  }, .parallel = parallel) %>%
  rbindlist(fill = T) %>%
  merge_project()

corrob_dat_multiple_alleles <- corrob_dat_multiple_alleles[,
  merge_hla(.SD, anchor_hla = .SD[, hla_allele[1]],
    percentile_rank = 1.9, hla_corrob_thresh = .2, simplify = T),
  by = hla_allele]

corrob_dat_multiple_alleles[,
  'frac_peps_promiscuous' := N_promiscuous / N_anchor_peps]

w_saveRDS('corrob_dat_multiple_alleles')
```

Analyse if and why donors are missing in new output

```{r, warning=FALSE, echo=FALSE}
# idx = 250
# donor_id <- as.character(mygrid[idx, 'donor_id'])
# hla_allele <- as.character(mygrid[idx, 'hla_allele'])
# find_donor_overlap(donor_id = donor_id,
#   hla_allele = hla_allele,
#   percentile_rank = 1.9)

cond_rm(corrob_dat_multiple_alleles)
# w_readRDS('corrob_dat_multiple_alleles')
if (exists('corrob_dat_multiple_alleles')) {
  ## Investigate why some donors are missing from new output All donors had at
  ## most 1 or 2 peptides in original. Inspection of the first patient showed
  ## that 1 peptide passed all filters, except for NMD. It's likely that the NMD
  ## filter wasn't turned on by default when the original corrob_dat was
  ## generated and as such the small set of 'lost' peptides are lost all
  ## filtered out by the NMD filter.
  w_readRDS('corrob_dat')
  missing_donors <- setdiff(corrob_dat[, sort(unique(donor_id))],
    corrob_dat_multiple_alleles[hla_allele == 'A0201', donor_id])
  extra_donors <- setdiff(
    corrob_dat_multiple_alleles[hla_allele == 'A0201', donor_id],
    corrob_dat[, sort(unique(donor_id))])

  setkey(corrob_dat, donor_id)
  corrob_dat[missing_donors]

  res <- plyr::llply(missing_donors, function(did) {
    corrob_dat_multiple_alleles[donor_id == did]
    lres <- find_donor_overlap(donor_id = did, anchor_hla_allele = 'A0201',
      percentile_rank = 1.9)
    print(did)
    print(lres)
    return(lres)
  }, .parallel = F)
  rbindlist(res)
}
```

Plot results in histograms

```{r, warning=FALSE, echo=FALSE}
devtools::load_all(file.path('~/antigenic_space', 'libs', 'fasanalysis'))
devtools::load_all(file.path('~/libs', 'quickMHC'))
w_readRDS('corrob_dat_multiple_alleles')
# corrob_dat_multiple_alleles[, .N, by = .(hla_allele, percentile_rank)]
hla_corrob_thresh = .05

plots <- lapply(hlas, function(l_hla) {
  x_lab <- paste('Fraction of', quickMHC::complement_HLA(l_hla),
  'peptides presented\nby any of patient\'s other HLA-A & HLA-B alleles')

  p_b <- corrob_dat_multiple_alleles[hla_allele == l_hla] %>%
    merge_hla(
      anchor_hla = l_hla, percentile_rank = 1.9,
      hla_corrob_thresh = hla_corrob_thresh) %>%
    { .[, 'frac_bin' := cut(frac_peps_promiscuous, include.lowest = T,
      labels = c('0-10%', '10-20%', '20-30%', '30-40%', '40-50%', '50-60%',
        '60-70%', '70-80%', '80-90%', '90-100%'),
      breaks = seq(0, 1, by = .1))] } %>%
    { .[, .(.N), by = .(hla_allele_status, frac_bin)] } %>%
    ggplot(aes(x = frac_bin, fill = hla_allele_status, y = N)) +
    geom_col(alpha = .8, position = position_dodge()) +
    scale_x_discrete(name = x_lab, expand = c(0, 0)) +
    scale_y_continuous(name = 'Patient count', expand = c(0, 0)) +
    scale_fill_manual(name = '',
      values = gen_editing_palette(dtf = corrob_dat_multiple_alleles)) +
    theme_fas(panel.grid.minor = element_blank(),
      panel.grid.major.x = element_blank(),
      legend.background = element_blank(),
      # legend.justification = c(0, 1),
      # legend.position = c(.05, .95),
      legend.position = 'top') +
    rotate_x_labels(45)
  # maartenutils::w_ggsave(plot = p_b, fn = 'hla_class_patient_dist',
  #   img_folder = grob_loc,
  #   filetypes = c('pdf', 'grob'),
  #   w=90, h=80, units = 'mm')
  return(p_b)
})
# dev.off()

fn <- file.path(img_loc,
  sprintf('panel_patient_rep_promiscuity_%.1f.pdf', hla_corrob_thresh))
tab <- maartenutils::plot_panel_layout(plots,
  filename = fn, labels = NULL, w = 8.7, h = 25, ncol = 1, nrow = 5)
sys_file_open(fn)
# print(p_b)
```

Verify merging HLA works as expected. Why do the control group patients for the
non-A0201 alleles display such has high peptide promiscuity rates? It this by
chance?

```{r, warning=FALSE, echo=FALSE}
library(ggExtra)
w_readRDS('corrob_dat_multiple_alleles')
l_hla <- 'A1101'
l_hla <- 'B2705'
l_hla <- 'B0702'
l_hla <- 'A0201'
l_hla <- 'B4001'

t_dats <- lapply(auto_name(hlas), function(l_hla) {
  t_dat <- corrob_dat_multiple_alleles[hla_allele == l_hla] %>%
    merge_hla(anchor_hla = l_hla, hla_corrob_thresh = .2)

  t_dat[, .(hla_a1, hla_a2, hla_b1, hla_b2)] %>%
  apply(1, function(alleles) {
    setNames(corrob_hla_2D[['1.9']][l_hla, alleles], NULL)
  }) %>%
  t %>% {
    cbind(., 'sum_ind_alleles' = apply(., 1, sum))
  } %>%
  as.data.table %>%
  cbind('donor_id' = t_dat$donor_id) %>%
  controlled_merge(t_dat) %>%
  dplyr::select(donor_id, V1, V2, V3, V4, hla_a1, hla_a2, hla_b1, hla_b2,
    sum_ind_alleles, hla_allele_status, frac_peps_promiscuous, N_anchor_peps)
})
```

```{r, warning=FALSE, echo=FALSE}
t_dat <- t_dats[[1]]
## 2019-01-05 13:11
## Within the group of patients that were previously classified as the reference
## group (when only A-alleles were considered), what percentage of patients
## really was a A2-like patient based on the B-alleles as well?
t_dat[V1 < .2 & V2 < .2, mean(V3 >= .2 | V4 >= .2)]
t_dat[V1 < .2 & V2 < .2, .N, by = .(V3 >= .2 | V4 >= .2)]
328 / (328 + 2018)
(328 + 2018)
```

```{r, warning=FALSE, echo=FALSE}
plots <- purrr::imap(t_dats, function(dtf, l_hla) {
  p1 <- ggplot(dtf,
    aes(x = N_anchor_peps, y = frac_peps_promiscuous,
      colour = hla_allele_status, alpha = .5)) +
    geom_point() +
    scale_x_continuous(trans = 'log10') +
    theme_fas(base_size = 8, legend.pos = 'bottom') +
    ggtitle(l_hla)

  p2 <- ggplot(dtf,
    aes(x = sum_ind_alleles, y = frac_peps_promiscuous, size = N_anchor_peps,
      colour = hla_allele_status, alpha = N_anchor_peps)) +
    geom_point() +
    theme_fas(base_size = 8, legend.pos = 'bottom') +
    ggtitle(l_hla)

  list(ggMarginal(p1, groupColour = TRUE, groupFill = TRUE),
       ggMarginal(p2, groupColour = TRUE, groupFill = TRUE))
})

fn <- file.path(img_loc, 'corrob_vs_ds_hla_overlap.pdf')
maartenutils::plot_panel_layout(unlist(plots, recursive = F),
  filename = fn, labels = NULL, w = 17.4, h = 25, ncol = 2, nrow = 3)
sys_file_open(fn)
```

2019-01-04 14:23 Can this overlap be explained on the allele level? I.e. are the
new four alleles corroborated to a higher degree? One naive way to look into
this is to sum all the corroboration coefficients for each of the alleles. Of
course, this method is flawed as it does not account for allelic prevalence and
co-incidence patterns. Nevertheless, A0201 is not an outlier in this respect.

```{r, warning=FALSE, echo=FALSE}
t_dat <- corrob_hla_2D[['1.9']][hlas, ]
apply(t_dat, 1, sum)
lapply(names(t_dats), function(hla_allele) {
  dtf <- t_dats[[hla_allele]]
  dtf[, .('anchor_hla' = hla_allele,
    hla_allele_status, sum_ind_alleles, frac_peps_promiscuous)]
}) %>% rbindlist
```

Functional dependency of HLA corroboration threshold on the amount of donors in
the reference/control group per allele

```{r, warning=FALSE, echo=FALSE}
devtools::load_all(file.path('~/antigenic_space', 'libs', 'fasanalysis'))

hct_titration <- lapply(seq(0, 1, by = .05), function(hct) {
  message(hct)
  ct <- copy(w_readRDS('corrob_dat_multiple_alleles'))
  ct <- lapply(ct[, unique(hla_allele)], function(hla_allele) {
    merge_hla(ct[hla_allele == parent.frame(4)$hla_allele],
      anchor_hla = hla_allele, hla_corrob_thresh = hct)
    }) %>% rbindlist %>% .[, 'hct' := hct]
  # ct <- ct[, merge_hla(.SD,
  #     anchor_hla = .SD[, hla_allele[1]], percentile_rank = 1.9,
  #     hla_corrob_thresh = hct), by = hla_allele]
  ct <- clean_columns(instance = 'hct_titration', ct,
    col_names = c('hla_a1', 'hla_a2', 'hla_b1', 'hla_b2'))
  return(ct)
}) %>% rbindlist(fill = T)
```

```{r, warning=FALSE, echo=FALSE}
# hla_allele_status == 'no anchor-like'
p1 <- hct_titration[,
  .N, by = .(hla_allele, hct, hla_allele_status)] %>%
  ggplot(aes(x = hct, y = N, colour = hla_allele, group = hla_allele)) +
    geom_point() +
    geom_line() +
    facet_grid(cols = vars(hla_allele_status)) +
    theme_fas()

# devtools::install(file.path('~/libs', 'maartenutils'))
fn <- maartenutils::w_ggsave(plot = p1, fn = 'hct_titration',
  img_folder = img_loc, filetypes = c('pdf'),
  w=174, h=90, units = 'mm')
sys_file_open(fn)
```

```{r, warning=FALSE, echo=FALSE}
corrob_hla_2D[['1.9']]['B2705', ]
```

```{r, warning=FALSE, echo=FALSE}
corrob_dat[, 1 - median(frac_peps_promiscuous), by = hla_a0201_status]
```

```{r, warning=FALSE, echo=FALSE}
p_c <- ggplot(corrob_dat, aes(x = frac_peps_promiscuous,
    y = a2_peps, color = hla_a0201_status)) +
  geom_count(alpha = .4, position = 'identity') +
  geom_smooth(se = F) +
  scale_y_continuous(name = 'HLA-A*02:01 peptides',
    trans = 'log10', position = 'top') +
  scale_x_continuous(name = x_lab) +
  scale_colour_manual(name = '',
    values = gen_editing_palette(dtf = corrob_dat)) +
  scale_size_continuous(name = 'Patient count', guide = F) +
  theme_fas(legend.justification = c(1, 1),
    legend.direction = 'horizontal',
    legend.background = element_blank(),
    # plot.margin = unit(c(.5, .0, .0, 1), 'cm'),
    legend.position = c(.95, .95))

if (F) {
  tab <- maartenutils::plot_panel_layout(list(p_a, p_b, p_c))
  # ggsave('hla-a0201_promiscuous_peptides.pdf',
  #        width = 25, height=8, units = 'cm')
  pdf(file = 'hla-a0201_promiscuous_peptides.pdf',
      width = 25/2.54, height=8/2.54)
  grid.draw(tab)
  dev.off()
}
```

```{r, warning=FALSE, echo=FALSE}
grid.newpage()
g_comb <- do.call(rbind, c(to_g(list(p_a, p_b)), size="first"))
grid.draw(g_comb)
```


```{r, warning=FALSE, echo=FALSE}
library(ggExtra)
p2 <- ggplot(corrob_dat,
  aes(x = frac_peps_promiscuous, y = a2_peps, color = hla_a0201_status)) +
  geom_count(alpha = .4, position = 'identity') +
  geom_smooth(se = F) +
  scale_y_continuous(name = 'HLA-A*02:01 peptides',
                     trans = 'log10',
                     position = 'top') +
  scale_x_continuous(name = 'Fraction of HLA-A*02:01 peptides presented by any of patient HLA-alleles',
                     position = 'top') +
  scale_colour_manual(name = '',
    values = gen_editing_palette(dtf = corrob_dat,
      hla_var = 'hla_a0201_status_b')) +
  scale_size_continuous(name = 'Patient count') +
  theme_fas(legend.justification = c(1, 1),
            legend.background = element_blank(),
            plot.margin = unit(c(.5, .0, .0, 1), 'cm'),
            legend.position = c(.95, .95))

ggMarginal(p2, data = corrob_dat, type = 'histogram', fill = hla_a0201_status)
```


```{r, warning=FALSE, echo=FALSE}
## TODO finish me
p2 <- ggplot(corrob_dat,
  aes(x = frac_peps_promiscuous, y = a2_peps, color = hla_a0201_status)) +
  geom_count(alpha = .4, position = 'identity') +
  geom_smooth(se = F) +
  scale_y_continuous(name = 'HLA-A*02:01 peptides',
                     trans = 'log10',
                     position = 'top') +
  scale_x_continuous(name = 'Fraction of HLA-A*02:01 peptides presented by any of patient HLA-alleles',
                     position = 'top') +
  scale_colour_manual(name = '', values = gen_color_vector(n = 3)) +
  scale_size_continuous(name = 'Patient count') +
  theme_fas(legend.justification = c(1, 1),
            legend.background = element_blank(),
            plot.margin = unit(c(.5, .0, .0, 1), 'cm'),
            legend.position = c(.95, .95))

p2_mary <- ggplot(corrob_dat, aes(x = a2_peps, fill = hla_a0201_status)) +
  geom_histogram(alpha = .4, position = 'stack') +
  scale_fill_manual(name = '', values = gen_color_vector(n = 3), guide = F) +
  scale_y_continuous(name = 'Patient count', expand = c(0, 0)) +
  scale_x_continuous(name = '', trans = 'log10') +
  scale_size_continuous(name = '') +
  coord_flip() +
  theme_fas(legend.justification = c(1, 1),
            legend.background = element_blank(),
            # axis.text.x = element_blank(),
            axis.text.y = element_blank(),
            axis.ticks.y = element_blank(),
            # plot.margin = unit(c(.5, .4, .5, 1), 'cm'),
            plot.margin = unit(c(.5, .4, 0, 0), 'cm'),
            legend.position = c(.95, .95))

p2_marx <- ggplot(corrob_dat, aes(x = frac_peps_promiscuous, fill = hla_a0201_status)) +
  geom_histogram(alpha = .4, position = 'stack') +
  scale_fill_manual(name = '', values = gen_color_vector(n = 3), guide = F) +
  scale_y_reverse(name = 'Patient count', expand = c(0, 0)) +
  scale_x_continuous(name = '', trans = 'identity') +
  scale_size_continuous(name = '') +
  theme_fas(legend.justification = c(1, 1),
            legend.background = element_blank(),
            axis.text.x = element_blank(),
            axis.ticks.x = element_blank(),
            # axis.text.y = element_blank(),
            # plot.margin = unit(c(.5, .4, .5, 1), 'cm'),
            plot.margin = unit(c(.5, .0, 0, 1), 'cm'),
            legend.position = c(.95, .95))

grobs <- list(p2, p2_marx, p2_mary)
p <- gridExtra::arrangeGrob(grobs = grobs,
                            layout_matrix = rbind(c(1, 2), c(3, NA)),
                            heights = c(.5, .5),
                            widths = c(.6, .4))
grid.newpage()
grid.draw(p)
```


```{r, warning=FALSE, echo=FALSE}
corrob_dat[, table(eps(frac_peps_promiscuous, 0))]
vec <- corrob_dat[hla_a0201_status == 'no HLA-A*02:01-like',
                  table(eps(frac_peps_promiscuous, 0))]
format_frac(vec[2], sum(vec))
```

